#summary How to access the basic parts of a git repository.

= The Repository =

All git related work can be said to somehow happen in the context of a repository. The repository is where git stores all its data, whether it is the content being tracked or the various "meta-data" containing state information. In JGit, a repository is represented by the Repository class. This class serves as the main entry-point for accessing the different resources provided by the repository on disk.

== Setting Up a Repository ==

To instantiate a repository, a `java.io.File` object representing the absolute path of the repository must be given. For non-bare repositories, this means that the `.git` directory should also be included, as in the code below.
{{{
try {
        File gitDir = new File("/path/to/repo/.git");
        Repository repo = new Repository(gitDir);
        // ... use the repository ...
        repo.close();
} catch (IOException ex) {
        // The repository exists, but is inaccessible!
}
}}}

If you want to create a completely new repository, the Repository class can also help you.
Using the `create()` method it will initialize an empty repository for you on disk using the path given via the File object.
{{{
try {
        File gitDir = new File("/path/to/new-repo/.git");
        Repository repo = new Repository(gitDir);
        repo.create();
        // ... use the new repository ...
} catch (IllegalStateException ise) {
        // The repository already exists!
} catch (IOException ioe) {
        // Failed to create the repository!
}
}}}
When creating repositories with JGit, no hooks will be installed.

*Note:* If creation of the new repository fails, the directories and files already created on disk are left untouched!

== The Configuration File ==

 * Getting and setting things from/in .git/config

== Repository References ==

Once the Repository has been instantiated, information about branches and other repository references are available. As a first example let's print the name of the current branch:
{{{
String head = repo.getFullBranch();
if (head.startsWith("refs/heads/")) {
        // Print branch name with "refs/heads/" stripped.
        System.out.println("Current branch is " + repo.getBranch());
}
}}}

As the name suggests repository references are "symbolic" links into the tracked content, and so often you are not interested in the actual reference, but in the what is being referenced. A first step to get there is to resolve the reference of interest. In the following example, we want to extend the previous example to also list the revision ID of the current branch.
{{{
try {
        // The following could also have been done using repo.resolve("HEAD")
        ObjectId id = repo.resolve(repo.getFullBranch());
        System.out.println("Branch " + repo.getBranch() + " points to " + id.name());
} catch (IOException ioe) {
        // Failed to resolve.
}
}}}

The `resolve()` method supports most of the revision expressions supported by git and can serve as an easy way to obtain the ID of the parent of a commit, or the tree ID of a commit.
{{{
try {
        ObjectId parent = repo.resolve("HEAD^");
        ObjectId tree = repo.resolve("HEAD^{tree}");
        System.out.println("HEAD has parent " + parent.name() + " and tree " + tree.name());
} catch (RevisionSyntaxException rse) {
        // Syntax error in the revision expression, e.g. HEAD~foo. or HEAD^{foo}
} catch (IncorrectObjectTypeException rse) {
        // Type expression applied to incorrect type, e.g. using ^{tree} on blob ID.
}
}}}

As a final note, all repository references are available as a map via the `getAllRefs()` method. The mapping is to instances of the Ref class, which allows easy access to both the reference name and ID.

== The Basic Object Model ==

If you are already familiar with how git stores data under the hood, the object model used by JGit should come quite natural to you. The content being tracked can be divided into different type: blob, tree, commit and tag. They are organized so that blobs are referenced by trees, trees are referenced by trees or commits, commits are referenced by commits, and tags can reference any object. This hierarchy are also used by JGit.

 * Inheritance: e.g. Commit "is an" ObjectId "is a" ..

 * ObjectId
 * Commit
 * Tag
 * Tree
 * Blob